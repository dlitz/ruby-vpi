= Welcome to Ruby-VPI

* Visit the {project portal}[http://rubyforge.org/projects/ruby-vpi] hosted generously by RubyForge[http://rubyforge.org]

* Ask for help or discuss in the {online forums}[http://rubyforge.org/forum/?group_id=1339]

* Report bugs or contribute patches in the {project tracker}[http://rubyforge.org/tracker/?group_id=1339]

* Get the newest source from the {code repository}[http://rubyforge.org/scm/?group_id=1339]

* Get the newest release from the {download area}[http://rubyforge.org/frs/?group_id=1339]

* See what has changed in the release history

= What is it?

Ruby-VPI is a Ruby[http://www.ruby-lang.org/en/20020101.html] interface to Verilog[http://en.wikipedia.org/wiki/Verilog] VPI. With it, you can create complex Verilog {test benches}[http://en.wikipedia.org/wiki/Software_testing] easily and wholly in Ruby.

= How is it licensed?

Ruby-VPI is {free software}[http://en.wikipedia.org/wiki/Free_software]; you can redistribute it and/or modify it under the terms of the {GNU General Public License}[http://www.gnu.org/copyleft/gpl.html] as published by the {Free Software Foundation}[http://www.fsf.org]; either version 2 of the License, or (at your option) any later version.

= How does it work?

1. A Verilog simulator simulates a Verilog test bench containing behavioral Verilog code.

1. The Verilog test bench invokes the <tt>$ruby_init(<i>command-line arguments</i>)</tt> task with command-line arguments for the Ruby interpreter. This task transfers control to the Ruby interpreter.

1. The Ruby interpreter scans its command-line arguments. Upon finding a Ruby script file within those arguments, the interpreter executes it.

1. The Ruby script file is executed until it calls the <tt>Vpi::relay_verilog</tt> method. This method transfers control to the Verilog test bench.

1. The Verilog simulator resumes simulation of the Verilog test bench.

= What are the alternatives?

RHDL[http://www.aracnet.com/~ptkwt/ruby_stuff/RHDL/]:: Ruby abstraction of VHDL and Verilog

MyHDL[http://myhdl.jandecaluwe.com]:: Python abstraction of Verilog

JOVE[http://jove.sourceforge.net]:: Java interface to VPI
{APVM/Oroboro}[http://sourceforge.net/projects/apvm]:: Python interface to VPI

ScriptEDA[http://embedded.eecs.berkeley.edu/Alumni/pinhong/scriptEDA/]:: Perl, Python, and Tcl interface to VPI

== Ye olde PLI

The following projects utilize the archaic +tf+ and +acc+ PLI interfaces, which have been officially deprecated in IEEE Std. 1364-2005.

ScriptSim[http://www.nelsim.com]:: Perl, Python, and Tcl/Tk interface to PLI

{Verilog::Pli}[http://www.veripool.com/verilog-pli.html]:: Perl interface to PLI

JPLI[http://www.time-rover.com/jpli/]:: Java interface to PLI

= How to compile it?

== Requirements

* A make[http://en.wikipedia.org/wiki/Make] program, such as {GNU make}[http://www.gnu.org/software/make/].

* A compiler for the C language, such as GCC[http://www.gnu.org/software/gcc/].

* Version 1.8 or newer of the Ruby[http://www.ruby-lang.org] interpreter, including header and linkable object files for building extensions.

* Version 1.3 or newer of the SWIG[http://www.swig.org] program.

* The {POSIX threads (pthreads)}[http://en.wikipedia.org/wiki/Pthreads] library, including header and linkable object files.

== Instructions

Run the <b>+make+</b> command to begin compilation. If it fails because of missing libraries, then install those libraries and try the compilation again. Otherwise edit the file named +makefile+ according to your build environment.

Remember, you can ask for help on the online forums.

= How to use it?

Ruby-VPI is not invoked directly by a Ruby script or by a user. Instead, it is invoked by a Verilog test bench which is simulated by a Verilog simulator.

== Which simulator is needed?

You should be able to use Ruby-VPI with any Verilog simulator. However, only the following simulators have been tested because we do not have knowledge of or access to other ones. Therefore, please share your experiences of using Ruby-VPI with other simulators, in the online forums.

{Icarus Verilog}[http://www.icarus.com/eda/Verilog/]:: Version 0.8 or newer is acceptable.

{GPL CVer}[http://www.pragmatic-c.com/gpl-cVer/]:: Version 2.11a is not yet acceptable.

{Synopsys VCS}[http://www.synopsys.com/products/simulation/simulation.html]:: Version X-2005.06 or newer is acceptable.

{Mentor Modelsim}[http://www.model.com]:: Version 6.1b newer is acceptable.

== Examples of usage

The +examples+ directory contains several example test benches that utilize Ruby-VPI. Each example has an associated +makefile+ to simplify the process of running it. Thus, simply navigate into an example directory and run the command <b><tt>make _abbreviation_</tt></b> where _abbreviation_ is the abbreviated name of your Verilog simulator shown in the table below.

<b>Simulator</b>:: <b>Abbreviation</b>
Icarus Verilog:: ivl
GPL Cver:: cver
Synopsys VCS:: vcs
Mentor Modelsim:: vsim

= Where is the documentation?

== C language

There is API documentation, generated by the Doxygen[http://doxygen.org] program, inside the <tt>src/html</tt> directory. This documentation is useful if you want to hack the core of Ruby-VPI, which connects a Verilog simulator to the Ruby interpreter.

== Ruby language

You're looking at it! This is the documentation for the Ruby portion of Ruby-VPI, generated by the RDoc program. It is useful if you want to write Ruby programs which utilize Ruby-VPI.

=== Verilog VPI

The _entire_ IEEE Std. 1364-2005 VPI interface (see <tt>src/vpi_user.h</tt>) is available inside Ruby, but with minor changes:

* The first letter in the name of every function, type, structure, and constant becomes capitalized. For example, the structure <tt><b>s</b>_vpi_value</tt> becomes <tt><b>S</b>_vpi_value</tt>, and the constant <tt><b>v</b>piIntVal</tt> becomes <tt><b>V</b>piIntVal</tt>.

* The functions <tt>vpi_vprintf</tt> and <tt>vpi_mcd_vprintf</tt> are disabled because some compilers have problems with pointers to the <tt>va_list</tt> type:

 void foo(va_list ap) {
  /* causes "type mismatch" error */
  va_list *p = &ap;
 }

Atop this interface sits the VPI utility layer (see <tt>src/vpi_util.rb</tt>) whose goal is to transform the VPI interface into something more Ruby-like. For example, it is more Ruby-like to write
 handle.each(VpiNet) {|net| . . .}
than
 if itr = vpi_iterate(VpiNet, handle)
  while net = vpi_scan(itr)
   . . .
  end
 end
throughout your code.

= Why doesn't it work?!

This section presents known problems and possible solutions.

== Ruby

=== SystemStackError

* This problem was fixed in release 0.2. If it still occurs, then please report it.

If a "stack level too deep (SystemStackError)" error occurs during the simulation, then increase the system-resource limit for stack-size by running the <tt>ulimit</tt> command before starting the simulation:

 $ ulimit -s unlimited
 $ ..your simulation..

=== test/unit

* This problem was fixed in release 0.2. If it still occurs, then please report it.

If you try to write a unit test inside the Ruby script file (which is invoked by a Verilog test bench), then you will get an error like this:
 /usr/lib/ruby/1.8/test/unit/ui/testrunnerutilities.rb:39: [BUG] cross-thread violation on rb_gc()

== Icarus Verilog 0.8

=== vpi_handle_by_name

==== Give full paths to Verilog objects

The <tt>vpi_handle_by_name()</tt> function requires an _absolute_ path (including the name of the test-bench which instantiates a module) to a Verilog object.

For example, for the Verilog file below, you need to specify <tt>TestFoo.my_foo.clk</tt> instead of <tt>my_foo.clk</tt> in order to access the <tt>clk</tt> input of the <tt>my_foo</tt> module instance.

 module TestFoo;
  reg clk_reg;
  Foo my_foo(.clk(clk_reg));
 endmodule;

==== Connect registers to something

If you want to access a register in a module, then it must be connected to something (either assigned to a wire or passed as a parameter to a module instantiation). Otherwise, Icarus will give you a <tt>nil</tt> value as the result of <tt>vpi_handle_by_name</tt>.

For example, suppose you wanted to access the "clk_reg" register in the <tt>TestFoo.rb</tt> test bench below.

===== TestFoo.rb

When used with the <tt>TestFoo_bad.v</tt> test bench shown below, the call to <tt>vpi_handle_by_name</tt> will return <tt>nil</tt>. However, when used with either the <tt>TestFoo_fix1.v</tt> or the <tt>TestFoo_fix2.v</tt> test bench shown below, the call to <tt>vpi_handle_by_name</tt> behaves as expected.
 clk_reg = vpi_handle_by_name("TestFoo.clk_reg", nil)

===== TestFoo_bad.v

Here the "clk_reg" register is not connected to anything.
 module TestFoo;
  reg clk_reg;
 endmodule;

===== TestFoo_fix1.v

Here we connect the "clk_reg" register to a wire.
 module TestFoo;
  reg clk_reg;
  wire clk_wire;
  assign clk_wire = clk_reg;
 endmodule;

===== TestFoo_fix2.v

Here we connect the "clk_reg" register to an instantiated module.
 module TestFoo;
  reg clk_reg;
  Foo my_foo(.clk(clk_reg));
 endmodule;

==== VPI::reset

* This method was removed in release 0.3; use <tt>Vpi::vpi_control(VpiReset)</tt> instead.

With version 0.8 of Icarus Verilog, the <tt>vpi_control(vpiReset)</tt> VPI function causes an assertion to fail inside the simulator. As a result, the simulation terminates and a core dump is produced.

== Mentor Modelsim

=== ruby_run();

* This problem was fixed in release 0.2. If it still occurs, then please report it.

Version 6.1b of Modelsim doesn't play nicely with either an embedded Ruby interpreter or POSIX threads in a PLI application. When Ruby-VPI invokes the <tt>ruby_run()</tt> function (which starts the Ruby interpreter), the simulator terminates immediately with an exit status of 0.

