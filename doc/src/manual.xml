<?xml version="1.0" encoding="utf-8"?>
<!--
	Copyright 2006 Suraj N. Kurapati.

	Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the file named "LICENSE".
-->

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
	<!-- imports -->
	<!ENTITY % sharedDTD SYSTEM "shared.dtd"> %sharedDTD;
	<!ENTITY license SYSTEM "license.xml">

	<!-- content -->
	<!ENTITY background.step3 "<para>Third, when the Ruby interpreter invokes the <code>Vpi::relay_verilog</code> method, &rv; pauses the Ruby interpreter and transfers control back to the Verilog simulator.</para>">

	<!ENTITY test-bench.ulink "<ulink url='http://en.wikipedia.org/wiki/Test_bench'>test bench</ulink>">
]>
<book lang="en">
	<bookinfo>
		<title>&rv; user's manual</title>

		&snk..copyright;

		<abstract>
			<para>This manual explains how to use &rv;. You can find the newest version of this manual at the <ulink url="&rv.url;">&rv; website</ulink>.</para>
		</abstract>

		<legalnotice>
			<para>Permission is granted to copy, distribute and/or modify this document under the terms of the &gnu; Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled "&gnu; Free Documentation License".</para>
		</legalnotice>
	</bookinfo>

	<chapter id="introduction">
		<title>Introduction</title>
		<para>&rv; is a &ruby..ulink; interface to <ulink url="http://en.wikipedia.org/wiki/Verilog">Verilog VPI</ulink>. It lets you create complex Verilog &test-bench.ulink;es easily and wholly in Ruby.</para>

		<section id="introduction.license">
			<title>License</title>
			<para>&rv; is <ulink url="http://en.wikipedia.org/wiki/Free_software">free software</ulink>; you can redistribute it and/or modify it under the terms of the <ulink url="http://www.gnu.org/copyleft/gpl.html">&gnu; General Public License</ulink> as published by the <ulink url="http://www.fsf.org">Free Software Foundation</ulink>; either version 2 of the License, or (at your option) any later version.</para>
		</section>

		<section id="introduction.resources">
			<title>Resources</title>

			<variablelist>
				<varlistentry>
					<term><ulink url="&rv.url-project;">Project portal</ulink></term>
					<listitem>
						<para>Hosted generously by <ulink url="http://rubyforge.org">RubyForge</ulink>.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><ulink url="&rv.url-project;">Project tracker</ulink></term>
					<listitem>
						<para>Report problems, contribute patches, and more.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><ulink url="&rv.url-download;">File releases</ulink></term>
					<listitem>
						<para>Get the newest release package.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><ulink url="&rv.url-source;">Source repository</ulink></term>
					<listitem>
						<para>Get the newest source code.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><ulink url="&rv.url-forum;">Online forums</ulink></term>
					<listitem>
						<para>Ask for help, give feedback, or discuss.</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</section>

		<section id="introduction.alternatives">
			<title>Alternatives</title>

			<para>The following projects are similar to &rv;. In that respect, they may be considered as alternatives.</para>

			<variablelist>
				<varlistentry>
					<term><ulink url="http://www.aracnet.com/~ptkwt/ruby_stuff/RHDL/">RHDL</ulink></term>
					<listitem>
						<para>Ruby abstraction of VHDL and Verilog.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><ulink url="http://myhdl.jandecaluwe.com">MyHDL</ulink></term>
					<listitem>
						<para>Python abstraction of Verilog.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><ulink url="http://jove.sourceforge.net">JOVE</ulink></term>
					<listitem>
						<para>Java interface to VPI.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><ulink url="http://embedded.eecs.berkeley.edu/Alumni/pinhong/scriptEDA/">ScriptEDA</ulink></term>
					<listitem>
						<para>Perl, Python, and Tcl interface to VPI.</para>
					</listitem>
				</varlistentry>
			</variablelist>

			<section id="introduction.alternatives.pli">
				<title>Ye olde PLI</title>
				<para>The following projects utilize the archaic <acronym>tf</acronym> and <abbrev>acc</abbrev> PLI interfaces, which have been officially deprecated in IEEE Std. 1364-2005.</para>

				<variablelist>
					<varlistentry>
						<term><ulink url="http://www.nelsim.com">ScriptSim</ulink></term>
						<listitem>
							<para>Perl, Python, and Tcl/Tk interface to PLI.</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><ulink url="http://www.veripool.com/verilog-pli.html">Verilog::Pli</ulink></term>
						<listitem>
							<para>Perl interface to PLI.</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><ulink url="http://www.time-rover.com/jpli/">JPLI</ulink></term>
						<listitem>
							<para>Java interface to PLI</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</section>
		</section>
	</chapter>

	<chapter id="background">
		<title>Background</title>

		<section id="background.test-bench">
			<title>Test bench</title>

			<para>A &test-bench.ulink; is a pretend, virtual environment used to verify the correctness or soundness of a Verilog model. The name <emphasis>test bench</emphasis> has its roots in testing of electronic devices, where an engineer would sit at a <emphasis>lab bench</emphasis>&mdash;furnished with tools of measurement and manipulation, such as oscilliscopes, multi-meters (to measure voltage, amperage, and resistance), soldering irons, wire cutters, and so on&mdash;and manually verify an electronic component.</para>

			<para>In our case, the test bench is defined by a Verilog simulator, a Verilog module, and &rv;. The first acts as the lab bench which provides measurement and manipulation tools. The second acts as the electronic component being verified by the engineer. The third acts as the engineer who measures, manipulates, and verifies the electronic component.</para>

			<para>However, unlike an enigneer who can verify an electronic component in real-time, the Verilog simulator and &rv; must take turns performing their duties. In particular, they take turns manipulating objects in the simulation and transfer control to each other when appropriate.</para>

			<para>The situation is similar to a pair of friends playing catch. One friend throws a ball to the other, and the other throws it back. Both are able to examine and modify the ball, but only when it is in hand.</para>

			<section id="background.test-bench.init">
				<title>Initialization</title>

				<figure id="fig..ruby_init">
					<title>Initialization of a test bench</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="figures/ruby_init.png"/>
						</imageobject>
					</mediaobject>
				</figure>

				<para>A test bench is first initialized before it is executed. During execution, a design (analogous to the electronic component being verified by an engineer) is exercised and its behavior is verified according to a specification.</para>

				<para><xref linkend="fig..ruby_init"/> illustrates the initialization process, which is described below.</para>

				<para>First, the Verilog simulator initializes &rv; by invoking the <code>$ruby_init();</code> system task/function, whose arguments represent the command-line invocation of the Ruby interpreter. For example, one would specify <code>$ruby_init("ruby", "-w");</code> in Verilog to acheive the same effect as specifying <code>ruby -w</code> at a command-prompt.</para>

				<para>Second, &rv; pauses the Verilog simulator and passes the arguments of the <code>$ruby_init();</code> system task/function to a Ruby interpreter.</para>

				&background.step3;
			</section>

			<section id="background.test-bench.exec">
				<title>Execution</title>

				<figure id="fig..ruby_relay">
					<title>Execution of a test bench</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="figures/ruby_relay.png"/>
						</imageobject>
					</mediaobject>
				</figure>

				<para>After a test bench is <link linkend="background.test-bench.init">initialized</link>, it is executed to verify a design. <xref linkend="fig..ruby_relay"/> illustrates the execution process, which is described below.</para>

				<para>First, the Verilog simulator transfers control to Ruby-VPI by invoking the <code>$ruby_relay();</code> system task/function.</para>

				<para>Second, &rv; pauses the Verilog simulator and resumes the Ruby interpreter.</para>

				&background.step3;
			</section>
		</section>
	</chapter>

	&license;
</book>
