<?xml version="1.0" encoding="utf-8"?>
<!--
	Copyright 2006 Suraj N. Kurapati.

	Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the file named "LICENSE".
-->

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
	<!-- imports -->
	<!ENTITY % sharedDTD SYSTEM "shared.dtd"> %sharedDTD;
	<!ENTITY license SYSTEM "license.xml">

	<!-- content -->
	<!ENTITY background.step3 "<para>Third, when the Ruby interpreter invokes the <code>Vpi::relay_verilog</code> method, &rv; pauses the Ruby interpreter and transfers control back to the Verilog simulator.</para>">

	<!ENTITY test-bench.gloss "<glossterm linkend='term..test-bench'>test bench</glossterm>">
	<!ENTITY test.gloss "<glossterm linkend='term..test'>test</glossterm>">
	<!ENTITY design.gloss "<glossterm linkend='term..design'>design</glossterm>">
	<!ENTITY specification.gloss "<glossterm linkend='term..specification'>specification</glossterm>">
	<!ENTITY bench.gloss "<glossterm linkend='term..bench'>bench</glossterm>">
]>
<book lang="en">
	<bookinfo>
		<title>&rv; user's manual</title>

		&snk..copyright;

		<abstract>
			<para>This manual explains how to use &rv;. You can find the newest version of this manual at the <ulink url="&rv.url;">&rv; website</ulink>.</para>
		</abstract>

		<legalnotice>
			<para>Permission is granted to copy, distribute and/or modify this document under the terms of the &gnu; Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled "&gnu; Free Documentation License".</para>
		</legalnotice>
	</bookinfo>

	<chapter id="introduction">
		<title>Introduction</title>
		<para>&rv; is a &ruby..ulink; interface to <ulink url="http://en.wikipedia.org/wiki/Verilog">Verilog VPI</ulink>. It lets you create complex Verilog &test-bench.gloss;es easily and wholly in Ruby.</para>

		<section id="introduction.license">
			<title>License</title>
			<para>&rv; is <ulink url="http://en.wikipedia.org/wiki/Free_software">free software</ulink>; you can redistribute it and/or modify it under the terms of the <ulink url="http://www.gnu.org/copyleft/gpl.html">&gnu; General Public License</ulink> as published by the <ulink url="http://www.fsf.org">Free Software Foundation</ulink>; either version 2 of the License, or (at your option) any later version.</para>
		</section>

		<section id="introduction.resources">
			<title>Resources</title>

			<variablelist>
				<varlistentry>
					<term><ulink url="&rv.url-project;">Project portal</ulink></term>
					<listitem>
						<para>Hosted generously by <ulink url="http://rubyforge.org">RubyForge</ulink>.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><ulink url="&rv.url-project;">Project tracker</ulink></term>
					<listitem>
						<para>Report problems, contribute patches, and more.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><ulink url="&rv.url-download;">File releases</ulink></term>
					<listitem>
						<para>Get the newest release package.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><ulink url="&rv.url-source;">Source repository</ulink></term>
					<listitem>
						<para>Get the newest source code.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><ulink url="&rv.url-forum;">Online forums</ulink></term>
					<listitem>
						<para>Ask for help, give feedback, or discuss.</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</section>

		<section id="introduction.alternatives">
			<title>Alternatives</title>

			<para>The following projects are similar to &rv;. In that respect, they may be considered as alternatives.</para>

			<variablelist>
				<varlistentry>
					<term><ulink url="http://www.aracnet.com/~ptkwt/ruby_stuff/RHDL/">RHDL</ulink></term>
					<listitem>
						<para>Ruby abstraction of VHDL and Verilog.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><ulink url="http://myhdl.jandecaluwe.com">MyHDL</ulink></term>
					<listitem>
						<para>Python abstraction of Verilog.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><ulink url="http://jove.sourceforge.net">JOVE</ulink></term>
					<listitem>
						<para>Java interface to VPI.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><ulink url="http://embedded.eecs.berkeley.edu/Alumni/pinhong/scriptEDA/">ScriptEDA</ulink></term>
					<listitem>
						<para>Perl, Python, and Tcl interface to VPI.</para>
					</listitem>
				</varlistentry>
			</variablelist>

			<section id="introduction.alternatives.pli">
				<title>Ye olde PLI</title>
				<para>The following projects utilize the archaic <acronym>tf</acronym> and <abbrev>acc</abbrev> PLI interfaces, which have been officially deprecated in IEEE Std. 1364-2005.</para>

				<variablelist>
					<varlistentry>
						<term><ulink url="http://www.nelsim.com">ScriptSim</ulink></term>
						<listitem>
							<para>Perl, Python, and Tcl/Tk interface to PLI.</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><ulink url="http://www.veripool.com/verilog-pli.html">Verilog::Pli</ulink></term>
						<listitem>
							<para>Perl interface to PLI.</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><ulink url="http://www.time-rover.com/jpli/">JPLI</ulink></term>
						<listitem>
							<para>Java interface to PLI</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</section>
		</section>
	</chapter>

	<chapter id="background">
		<title>Background</title>

		<para>&rv; is a &bench.gloss; which lets you &test.gloss; Verilog modules using the Ruby language.</para>

		<section id="background.terminology">
			<title>Terminology</title>

			<para>As a newcomer into the world of Verilog, I often heard the term &test-bench.gloss;: "I ran the test bench, but it didn't work!" or "Are you crazy?!! You <emphasis>still</emphasis> haven't written the test bench?!", for example. I searched my textbook and the Internet for a definition of the term, but it was to no avail. Instead, as if mocking my ignorance of what seems to be universal knowledge, both resources nonchalantly employed the term <emphasis>throughout</emphasis> their being. Ludicrous!</para>

			<para>Defeated, I turned to my inner faculties to determine the answer. "Let's see, the term &test-bench.gloss; has the word <emphasis>test</emphasis>&mdash;so maybe it has something to do with testing&mdash;and it has the word <emphasis>bench</emphasis>&mdash;so maybe it's referring to a table where the testing should occur". This reasoning became increasingly familiar as my mind rummaged through towering stores of obsolescence and ultimately retrieved those dreaded memories of sleepless weeks debugging electronics in the laboratory.</para>

			<para>"Aha!", I exclaimed hesitantly, trying to forget the past. The term has its roots in the testing of electronic devices, where an engineer like myself would sit at a bench in an electronics laboratory and verify that an electronic component satisfies some criteria. The bench would be furnished with tools of measurement and manipulation&mdash;such as oscilloscopes, voltmeters, soldering irons, and so on&mdash;which help the engineer to verify the electronic component or locate the sources of defects in the component.</para>

			<para>Alright, now I remember what a laboratory bench is, but how does it compare with the term &test-bench.gloss;? They both cannot have the same meaning, because it doesn't make sense to "run" a laboratory bench or to "write" one&mdash;unless you're equipped with a hammer and chisel. So what <emphasis>are</emphasis> these people referring to when they speak of "running" and "writing" test benches?</para>

			<para>I still don't know. Thus, to avoid propogating such confusion into this manual, I tried to disambiguate the terminology by <link linkend="glossary">simplifying and reintroducing it in a new light</link>.</para>
		</section>

		<section id="background.organization">
			<title>Organization</title>

				<figure id="fig..organization">
					<title>Overall organization of a test</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="figures/organization.png"/>
						</imageobject>
					</mediaobject>
				</figure>

			<para>As <xref linkend="fig..organization"/> shows, a &test.gloss; is composed of &rv;, a &design.gloss;, and a &specification.gloss;. To extend the <link linkend="background.terminology">analogy of an electronics laboratory</link>, the first acts as the laboratory bench which provides measurement and manipulation tools. The second acts as the electronic component being verified by the engineer. And the third acts as the engineer who measures, manipulates, and verifies the electronic component.</para>

			<figure id="fig..organization_detail">
				<title>Detailed organization of a test</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="figures/organization_detailed.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>TODO</para>

			<para>However, unlike an engineer who can verify an electronic component in real-time, the Verilog simulator and &rv; must take turns performing their duties. In particular, they take turns manipulating objects in the simulation and transfer control to each other when appropriate.</para>

			<para>The situation is similar to a pair of friends playing catch. One friend throws a ball to the other, and the other throws it back. Both are able to examine and modify the ball, but only when it is in hand.</para>
		</section>

		<section id="background.initialization">
			<title>Initialization</title>

			<figure id="fig..ruby_init">
				<title>Initialization of a test bench</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="figures/ruby_init.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>A test bench is first initialized before it is executed. During execution, a design (analogous to the electronic component being verified by an engineer) is exercised and its behavior is verified according to a specification.</para>

			<para><xref linkend="fig..ruby_init"/> illustrates the initialization process, which is described below.</para>

			<para>First, the Verilog simulator initializes &rv; by invoking the <code>$ruby_init();</code> system task/function, whose arguments represent the command-line invocation of the Ruby interpreter. For example, one would specify <code>$ruby_init("ruby", "-w");</code> in Verilog to achieve the same effect as specifying <code>ruby -w</code> at a command-prompt.</para>

			<para>Second, &rv; pauses the Verilog simulator and passes the arguments of the <code>$ruby_init();</code> system task/function to a Ruby interpreter.</para>

			&background.step3;
		</section>

		<section id="background.execution">
			<title>Execution</title>

			<figure id="fig..ruby_relay">
				<title>Execution of a test bench</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="figures/ruby_relay.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>After a test bench is <link linkend="background.initialization">initialized</link>, it is executed to verify a design. <xref linkend="fig..ruby_relay"/> illustrates the execution process, which is described below.</para>

			<para>First, the Verilog simulator transfers control to &rv; by invoking the <code>$ruby_relay();</code> system task/function.</para>

			<para>Second, &rv; pauses the Verilog simulator and resumes the Ruby interpreter.</para>

			&background.step3;
		</section>
	</chapter>

	<glossary id="glossary">
		<glossdiv>
			<title>B</title>

			<glossentry id="term..bench">
				<glossterm>Bench</glossterm>
				<glossdef>
					<para>An environment in which a &design.gloss; is verified against a &specification.gloss;. Often, it is made to emulate conditions in which the &design.gloss; will be eventually deployed.</para>
				</glossdef>
			</glossentry>
		</glossdiv>

		<glossdiv>
			<title>D</title>

			<glossentry id="term..design">
				<glossterm>Design</glossterm>
				<glossdef>
					<para>An idea or entity that is verified against a &specification.gloss; in order to ensure correctness or soundness of its being.</para>
				</glossdef>
			</glossentry>
		</glossdiv>

		<glossdiv>
			<title>S</title>

			<glossentry id="term..specification">
				<glossterm>Specification</glossterm>
				<glossdef>
					<para>A collection of expectations that must be satisfied by a &design.gloss; when subjected to certain conditions.</para>
				</glossdef>
			</glossentry>
		</glossdiv>

		<glossdiv>
			<title>T</title>

			<glossentry id="term..test">
				<glossterm>Test</glossterm>
				<glossdef>
					<para>The act of verifying a &design.gloss; against a &specification.gloss; in a &bench.gloss;.</para>
					<glossseealso otherterm="term..test-bench"/>
				</glossdef>
			</glossentry>

			<glossentry id="term..test-bench">
				<glossterm>Test bench</glossterm>
				<glossdef>
					<para>An allusion to <link linkend="background.terminology">a bench in an electronics laboratory</link>, or so it seems.</para>
					<glossseealso otherterm="term..test"/>
				</glossdef>
			</glossentry>
		</glossdiv>
	</glossary>

	&license;
</book>
