/*
  Copyright 2006 Suraj N. Kurapati
  See the file named LICENSE for details.
*/

#ifndef RELAY_CIN
#define RELAY_CIN

    #include "relay.h"
    #include "binding.h"

    // thread-safe mailboxes for synchronization between Ruby and C
    static VALUE RubyVPI_relay_toRuby = Qnil;
    static VALUE RubyVPI_relay_toC = Qnil;

    static ID RubyVPI_relay_cQueue_enq = 0;
    static ID RubyVPI_relay_cQueue_deq = 0;

    static void RubyVPI_relay_wake_up_c()
    {
        RubyVPI_util_debug("R: wake up C");
        rb_funcall(RubyVPI_relay_toC, RubyVPI_relay_cQueue_enq, 1, Qnil);
    }

    ///
    /// Allows the Ruby thread to continue execution.
    ///
    static void RubyVPI_relay_wake_up_ruby(VALUE token)
    {
        RubyVPI_util_debug("C: wake up Ruby");
        rb_funcall(RubyVPI_relay_toRuby, RubyVPI_relay_cQueue_enq, 1, token);
    }

    static VALUE RubyVPI_relay_wait_for_c()
    {
        RubyVPI_util_debug("R: wait for C");
        return rb_funcall(RubyVPI_relay_toRuby, RubyVPI_relay_cQueue_deq, 0);
    }

    ///
    /// Makes the C program wait until the Ruby
    /// thread finishes running (for now).
    ///
    static VALUE RubyVPI_relay_wait_for_ruby()
    {
        RubyVPI_util_debug("C: wait for Ruby");
        return rb_funcall(RubyVPI_relay_toC, RubyVPI_relay_cQueue_deq, 0);
    }

    ///
    /// Transfers control from the Ruby script
    /// to the C program and pauses Ruby.
    ///
    /// This function must be invoked only by Ruby.
    ///
    static VALUE RubyVPI_relay_from_ruby_to_c(VALUE self)
    {
        RubyVPI_util_debug("R: relay to C");
        RubyVPI_relay_wake_up_c();
        return RubyVPI_relay_wait_for_c();
    }

    static PLI_INT32 RubyVPI_relay_from_c_to_ruby(p_cb_data aCallback)
    {
        RubyVPI_util_debug("C: handling callback: %p", aCallback);

        // obtain the callback corresponding to the
        // current invocation of *this* callback handler
        VALUE call = RubyVPI_binding_rubyize_callback(aCallback);

        RubyVPI_util_debug("C: relay to Ruby");
        RubyVPI_relay_wake_up_ruby(call); // pass the callback to Ruby
        VALUE token = RubyVPI_relay_wait_for_ruby();

        return 0;
    }

    static void RubyVPI_relay_init()
    {
        RubyVPI_relay_cQueue_enq = rb_intern("enq");
        RubyVPI_relay_cQueue_deq = rb_intern("deq");

        // init the mailboxes
        rb_require("thread");
        VALUE cQueue = rb_const_get(rb_cObject, rb_intern("Queue"));

        RubyVPI_relay_toRuby = rb_class_new_instance(0, 0, cQueue);
        RubyVPI_relay_toC = rb_class_new_instance(0, 0, cQueue);

        // export relay function to Ruby
        VALUE module = rb_define_module("RubyVPI");
        rb_define_module_function(module, "__extension__relay_to_verilog", RubyVPI_relay_from_ruby_to_c, 0);
    }

#endif
