/*
	Copyright 2006 Suraj Kurapati
	Copyright 1999 Kazuhiro HIWADA

	This file is part of Ruby-VPI.

	Ruby-VPI is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

	Ruby-VPI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

	You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <ruby.h>
#include "verilog.h"
#include "RHandle.hin"
#include "RVPI.hin"


void Init_RVPI() {
	// register the VPI module
	RVPI__rModuleDef = rb_define_module("VPI");
	rb_define_module_function(RVPI__rModuleDef, "relay_verilog", RVPI_rb_relay_verilog, 0);
	rb_define_module_function(RVPI__rModuleDef, "handle_by_name", RVPI_rb_handle_by_name, -1);

	// rb_define_module_function(RVPI__rModuleDef, "control", RVPI_rb_control, -1);
	rb_define_module_function(RVPI__rModuleDef, "stop", RVPI_rb_stop, -1);
	rb_define_module_function(RVPI__rModuleDef, "finish", RVPI_rb_finish, -1);
	rb_define_module_function(RVPI__rModuleDef, "reset", RVPI_rb_reset, -1);


	// register classes beneath the VPI module
	Init_RHandle();
}

static VALUE RVPI_rb_relay_verilog(VALUE arSelf) {
	relay_verilog();
	return arSelf;
}

static VALUE RVPI_rb_handle_by_name(int aNumArgs, VALUE* aprArgs, VALUE arSelf) {
	// parse arguments
	VALUE rName, rParent;
	rb_scan_args(aNumArgs, aprArgs, "11", &rName, &rParent);


	// raise unless parent is a Handle
	vpiHandle vParent = NULL;

	if(rParent != Qnil) {
		RHandle_ensureType(rParent);
		vParent = *RHandle_get(rParent);
	}


	// prepare args for vpi_handle_by_name
	rName = rb_str_to_str(rName);
	PLI_BYTE8* name = StringValueCStr(rName);


	// return result of vpi_handle_by_name
	vpiHandle vHandle = vpi_handle_by_name(name, vParent);
	common_debug("vpi_handle_by_name(%s) => %p", name, vHandle);

	VALUE rHandle = rb_class_new_instance(0, NULL, RHandle__rClassDef);
	RHandle_set(rHandle, vHandle);

	return rHandle;
}

/**
	Helper function for 'stop' and 'finish' methods.

	@param	avOperation	The first argument to vpi_control.
*/
static VALUE RVPI_stop_finish_helper(int aNumArgs, VALUE* aprArgs, VALUE arSelf, int avOperation) {
	// parse arguments
	VALUE rDiagVal;
	rb_scan_args(aNumArgs, aprArgs, "01", &rDiagVal);
	common_debug("rDiagVal => %p", (void*)rDiagVal);
	common_debug("rDiagVal is nil? %s", common_boolToStr(rDiagVal == Qnil));


	if(rDiagVal != Qnil)
		vpi_control(avOperation, NUM2INT(rDiagVal));
	else
		vpi_control(avOperation);

	return arSelf;
}

static VALUE RVPI_rb_stop(int aNumArgs, VALUE* aprArgs, VALUE arSelf) {
	return RVPI_stop_finish_helper(aNumArgs, aprArgs, arSelf, vpiStop);
}

static VALUE RVPI_rb_finish(int aNumArgs, VALUE* aprArgs, VALUE arSelf) {
	return RVPI_stop_finish_helper(aNumArgs, aprArgs, arSelf, vpiFinish);
}

static VALUE RVPI_rb_reset(int aNumArgs, VALUE* aprArgs, VALUE arSelf) {
	// parse arguments
	VALUE rStopVal, rResetVal, rDiagVal;
	rb_scan_args(aNumArgs, aprArgs, "03", &rStopVal, &rResetVal, &rDiagVal);


	// prepare args for vpi_control
	PLI_INT32 stopVal = 0
		, resetVal = 0
		, diagVal = 0
	;

	if(rStopVal != Qnil) {
		// NOTE: see IEEE Std. 1364-2001, appendix C.7 for details
		if(rStopVal == Qtrue)
			stopVal = 0;
		else if (rStopVal == Qfalse)
			stopVal = 1;
		else
			stopVal = NUM2INT(rStopVal);
	}

	if(rResetVal != Qnil)
		resetVal = NUM2INT(rResetVal);

	if(rDiagVal != Qnil)
		diagVal = NUM2INT(rDiagVal);


	vpi_control(vpiReset, stopVal, resetVal, diagVal);

	return arSelf;
}
