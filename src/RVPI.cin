/*
	Copyright 2006 Suraj Kurapati
	Copyright 1999 Kazuhiro HIWADA

	This file is part of Ruby-VPI.

	Ruby-VPI is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

	Ruby-VPI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

	You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <ruby.h>
#include "verilog.h"
#include "RHandle.hin"
#include "RVPI.hin"


void Init_RVPI() {
	// register the VPI module
	RVPI__rModuleDef = rb_define_module("VPI");
	rb_define_module_function(RVPI__rModuleDef, "relay_verilog", RVPI_rb_relay_verilog, 0);
	rb_define_module_function(RVPI__rModuleDef, "register_task", RVPI_rb_register_task, 1);
	rb_define_module_function(RVPI__rModuleDef, "handle_by_name", RVPI_rb_handle_by_name, 2);


	// register classes beneath the VPI module
	Init_RHandle();
}

static VALUE RVPI_rb_relay_verilog(VALUE arSelf) {
	relay_verilog();
	return arSelf;
}

static VALUE RVPI_rb_register_task(VALUE arSelf, VALUE arTaskName) {
	// create registry if necessary
	if(RVPI__rTaskRegistry == Qnil) {
		RVPI__rTaskRegistry = rb_hash_new();
	}


	VALUE rName = rb_str_to_str(arTaskName);
	PLI_BYTE8* name = (PLI_BYTE8*)StringValueCStr(rName);


	// raise if no block given
	if(!rb_block_given_p()) {
		rb_raise(rb_eArgError, "no block given for task: %s", name);
	}


	// raise if task name already registered
	if(rb_hash_aref(RVPI__rTaskRegistry, rName) != Qnil) {
		rb_raise(rb_eArgError, "task has already been registered: %s", name);
	}


	// register the task
	VALUE rTask = rb_block_proc();	// convert the given block into a proc, which we can later call
	rb_hash_aset(RVPI__rTaskRegistry, rName, rTask);
	assert(rb_hash_aref(RVPI__rTaskRegistry, rName) == rTask);

	common_debug("registered task: %s", name);


	return arSelf;
}

static VALUE RVPI_rb_handle_by_name(VALUE arSelf, VALUE arName, VALUE arParent) {
	// raise unless parent is a Handle
	vpiHandle vParent = NULL;

	if(arParent != Qnil) {
		RHandle_ensureType(arParent);
		vParent = *RHandle_get(arParent);
	}


	// prepare args for vpi_handle_by_name
	VALUE rName = rb_str_to_str(arName);
	PLI_BYTE8* name = StringValueCStr(rName);


	// return result of vpi_handle_by_name
	VALUE rHandle = rb_class_new_instance(0, NULL, RHandle__rClassDef);
	RHandle_set(rHandle, vpi_handle_by_name(name, vParent));

	return rHandle;
}
