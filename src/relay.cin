/*
	Copyright 2006 Suraj Kurapati
	Copyright 1999 Kazuhiro HIWADA

	This file is part of Ruby-VPI.

	Ruby-VPI is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

	Ruby-VPI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

	You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#ifndef RELAY_CIN
#define RELAY_CIN

	#include <stdlib.h>
	#include <pthread.h>
	#include <ruby.h>

	#include "verilog.h"
	#include "common.h"

	#include "relay.hin"
	#include "swig.hin"


	static pthread_t relay__rubyThread;
	static pthread_mutex_t relay__rubyLock;
	static pthread_mutex_t relay__verilogLock;

	static void relay_init() {
		pthread_mutex_init(&relay__rubyLock, NULL);
		pthread_mutex_lock(&relay__rubyLock);
		pthread_mutex_init(&relay__verilogLock, NULL);
		pthread_mutex_lock(&relay__verilogLock);
	}

	static void relay_ruby() {
		pthread_mutex_unlock(&relay__rubyLock);
		pthread_mutex_lock(&relay__verilogLock);
	}

	static void relay_verilog() {
		pthread_mutex_unlock(&relay__verilogLock);
		pthread_mutex_lock(&relay__rubyLock);
	}

	typedef struct {
		PLI_BYTE8** args;
		uint count;
	} relay__RubyOptions__def;

	/**
		@param	apRubyOptions	relay__RubyOptions__def structure which contains command-line options passsed to the Ruby interpreter.
		@note	The structure will be freed *deeply* after use.
	*/
	static void* ruby_run_handshake(void* apRubyOptions) {
		// initialize Ruby interpreter
		ruby_init();
		ruby_init_loadpath();

		relay__RubyOptions__def* pRubyOptions = (relay__RubyOptions__def*) apRubyOptions;

		PLI_BYTE8** argv = pRubyOptions->args;
		uint argc = pRubyOptions->count;

		common_debug("got %d options => %p", argc, argv);

		uint i;
		for (i = 0; i < argc; i++) {
			common_debug("passing option %d to ruby: %s", i, argv[i]);
		}

		ruby_options(argc, argv);

		// free the memory used by command-line options
		for (i = 0; i < argc; i++) {
			common_debug("freeing option %d => %s", i, argv[i]);
			free(argv[i]);
		}

		free(argv);
		free(pRubyOptions);

		// Init_RVPI();
		swig_init();


		// start Ruby interpreter
		ruby_run();	// FIXME: terminates the main process when used with vsim
		return NULL;
	}

	static void relay_ruby_run() {
		relay__RubyOptions__def* pRubyOptions = malloc(sizeof(relay__RubyOptions__def));

		if (pRubyOptions) {
			pRubyOptions->args = NULL;
			pRubyOptions->count = 0;

			// transform the arguments passed to this function by Verilog into command-line arguments for Ruby interpeter
			vpiHandle vCall = vpi_handle(vpiSysTfCall, NULL);

			if (vCall) {
				vpiHandle vCallArgs = vpi_iterate(vpiArgument, vCall);

				if (vCallArgs) {
					vpiHandle vArg;
					s_vpi_value argVal;
					argVal.format = vpiStringVal;

					while ((vArg = vpi_scan(vCallArgs)) != NULL) {
						vpi_get_value(vArg, &argVal);
						common_debug("created option %d => %s", pRubyOptions->count, argVal.value.str);

						pRubyOptions->count++;


						if (pRubyOptions->args == NULL)
							pRubyOptions->args = malloc(sizeof(PLI_BYTE8*) * pRubyOptions->count);
						else
							pRubyOptions->args = realloc(pRubyOptions->args, sizeof(PLI_BYTE8*) * pRubyOptions->count);

						pRubyOptions->args[pRubyOptions->count-1] = strdup(argVal.value.str);
					}
				}
			}


			common_debug("passed %d options => %p", pRubyOptions->count, pRubyOptions->args);
			pthread_create(&relay__rubyThread, 0, ruby_run_handshake, pRubyOptions);
		}
		else {
			common_printf("error: unable to allocate memory for Ruby's command-line options.");
		}
	}

#endif
